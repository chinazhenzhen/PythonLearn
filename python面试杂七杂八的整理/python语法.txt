1.python 元类

2.生成器是迭代器的一种，但是你只能迭代它们一次，原因很简单，因为它们不是全部存在内存里，它们只在要调用的时候在内存里生成
（迭代器，可迭代的例如用列表推导式生成的列表，它是存在内存里的所以占用内存，所以你的函数要返回一个非常大的集合而且只需要读一次的话，用生成器非常
方便）

3.装饰器：
装饰器的作用就是为了已经存在的对象添加额外的功能，装饰器的好处就是你可以用它们来做任何事而不用重写。
静态方法 staticmethod  类方法 classmethod  （类方法和实例方法的区别，类方法不用实例化就可以被类这个对象调用，实例方法实例化之后才可以调用）
python一切皆对象，函数也是对象，因此，对象：可以赋值给一个变量，可以在其它函数里定义，这就意味着函数可以返回给另一个函数。
装饰器就是把其他函数作为参数的函数

装饰器写法样例：
# 装饰器就是把其他函数作为参数的函数
def my_shiny_new_decorator(a_function_to_decorate):
    # 在函数里面,装饰器在运行中定义函数: 包装.
    # 这个函数将被包装在原始函数的外面,所以可以在原始函数之前和之后执行其他代码..
    def the_wrapper_around_the_original_function():
        # 把要在原始函数被调用前的代码放在这里
        print "Before the function runs"  (原始函数被调用前的代码)
        # 调用原始函数(用括号)
        a_function_to_decorate()
        # 把要在原始函数调用后的代码放在这里
        print "After the function runs" （原始函数被调用后的代码）
    # 在这里"a_function_to_decorate" 函数永远不会被执行
    # 在这里返回刚才包装过的函数
    # 在包装函数里包含要在原始函数前后执行的代码.
    return the_wrapper_around_the_original_function  （返回装饰方法）

eg:flask——login(待补充)
4.函数重载
一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，
如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。
python不需要函数重载。

5.新式类（广度优先）、旧式类（深度优先）

6.__new__ 和 __init__ 的区别
__new__是一个静态方法,而__init__是一个实例方法.
__new__方法会返回一个创建的实例,而__init__什么都不返回.
只有在__new__返回一个cls的实例时后面的__init__才能被调用.
当创建一个新实例时调用__new__,初始化一个实例时用__init__.
__metaclass__(元类),创建类

7.单例模式

8.GIL全局解释器锁
Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，
python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。

9。协程（用户自己控制切换的时机）
协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,
而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.
Python里最常见的yield就是协程的思想!

什么是闭包？
理论：
闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它提高了代码的可重复使用性。
不同的语言实现闭包的方式不同。Python以函数对象为基础，为闭包这一语法结构提供支持的 。Python一切皆对象，函数这一语法结构也是一个对象。在函数对象中，我们像使用一个普通对象一样使用函数对象，比如更改函数对象的名字，或者将函数对象作为参数进行传递。（是高阶函数，用在函数式编程）（理解了闭包才能更好的理解装饰器，装饰器其实就是一个闭包函数？？）（函数做为一等公民的语言都存在闭包）
理解：
python有一个很有意思的地方，就是def函数可以嵌套在另一个def函数之中。调用外层函数时，运行到的内层def语句仅仅是完成对内层函数的定义，而不会去调用内层函数，除非在嵌套函数之后又显式的对其进行调用。
闭包的特点：
1. 必须有一个内嵌函数
2. 内嵌函数必须引用外部函数中的变量
3. 外部函数的返回值必须是内嵌函数

简单闭包函数：
def func(a,b): #外部函数
    def n_func(x): #内嵌函数
        return a*x+b
    return n_func

c = func(1,2)#一个函数结束的时候，会把自己的临时变量都释放还给内存，但是闭包并不会，他会保存变量的值
print(c(2))


11.lambda函数（配合map filter进行函数式编程）
解释：需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。
你在某处就真的只需要一个能做一件事情的函数而已，连它叫什么名字都无关紧要。Lambda 表达式就可以用来做这件事。
进一步讲，匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。
lambda表达式的格式：lambda input（输入） : output expression（输出表达式）

12 Python函数式编程
lambda + filter
>>>a = [1,2,3,4,5,6,7]
>>>b = filter(lambda x: x > 5, a)
>>>print b
>>>[6,7]
map+
>>> a = map(lambda x:x*2,[1,2,3])
>>> list(a)
[2, 4, 6]

13 Python2 和 Python3的区别
http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/

14 range 和 xrange 的区别 
都在循环时使用，xrange内存性能更好消耗更少的内存
range 返回的是列表  xrange返回的是生成器
python3 range和xrange合并（个人感觉是python2中的xrange变成了range）
